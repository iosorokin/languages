# Пет проект для помощи в изучении иностранных языков
Писал себе хелпер для изучения иностранных языков по фильмам книгам и музыке <br>
В проекте я больше оттачивал архитектуру и проводил постоянный рефакторинг, чем пытался его запустить <br>
Местами будет прослеживаться частая смена мысли, несвязный код и так далее. Следует понимать, что это полигон для испытаний,а не чистовик для продакшена <br>
Часть доменного кода была вынесена в src/WIP - это код со старой архитектурой, до введения DDD <br> 
После наработки разных практик, я перенёс архитектуру на симфони в другой пет проект в закрытом репозитории, а этот забросил. <br>

## Что я вынес из этого проекта:
- Вазделение слоёв на Модель, Презентатор, Базу данных, Приложение, Инфраструктуру.
- DDD - хорошая практика для разделения большой системы на маленькие логические компоненты.
- В моём случае предполагалась мультиязычность проекта, поэтому валидационные сообщения заменялись кодами ошибок и должны были подниматься в слой презентации, где все коды ошибок переводились бы на нужный язык в специальной службе локализации
- Научился писать приложения, в которых выбор фреймворка, базы данных, способа валидации и прочее не имеет никакого значения и может быть отложен на потом

### "Тихая валидация объектов-значений".  
Мне понравилась практика объектов-значений, но я долго не мог решить проблему их валидации. Выкидывать ошибку сразу в первом же объекте-значении было бы неправильным. <br>
Предполагался глобальный сборщик ошибок через статический валидатор, или валидатор-синглтон - но это всё были очень плохие решения <br>
В итоге я пришёл к схеме "тихой валидации" и замене сслыки на имплеметации объектов-значений ссылкой на их интерфейсы. <br>
Таким образом все объекты-значения присваиваются по интерфейсу. <br>
Конструкторы объектов значений запривачены, что не позволяет создать невалидное значение. <br>
У каждого объекта-значения есть статический конструктор, который подменяет инстанс валидного значения инвалидным. <br>
Все сущности имеют метод проверки целостной валидации. <br>
Этот метод может быть вызван в любом подходящем месте <br>
Метод проходит по объектам-значениям и проверяет принадлежность таких значений к инвалидному значению <br>
Таким образом собираются ошибки из сущности. <br>
В случае, когда валидацию забыли провести, попытка получения значения из инвалидного объекта-значения вызовет исключение, что сигнализирует разработчику о необходимости обработки валидации <br>

### Разделение валидатора на утверждения и коды ошибок
Стандартные валидаторы ларавель не позволяют обрабатывать ошибки без ведения записи сообщений валидации. <br>
Можно было бы решить это костылями но я разделил валидацию на две независымых реализации - утверждения и валидацию <br>
Утверждения делают обычные проверки, возвращая boolean значение <br>
Валидация же использует утвержджение и возвращает код ошибки <br>
В новом закрытом пет проекте на симфони я доработал эту схему и ввёл в структру ошибок Value, Error и ErrorBag классы. <br>
Error - содержит в себе данные об ошибке валидации. Если необходимо передать дополнительные параметры типа expect и actual, существует класс Value, который это описывает. ErrorBag - обычная коллекция ошибок. <br>
Валидация разделена на два этапа - валидация презентации, на уровне контроллеров проверяет типы данных и наличие обязательных атрибутов. Валидация на уровне домена происходит в объектах-значениях. <br>
Такая практика позволяет хранить особые сведения о валидации как можно ближе к месту использования атрибутов + исключает вариант наличия невалидных струкур данных в системе <br>
